// Twice feature showcase (grouped output)

fn header(name: string) {
  println("--- " + name + " ---");
  return;
}

fn demo_types_and_casts() {
  header("types and casts");

  type NumOrText = int||string;
  type Row = int[2];
  type Grid = Row[2];

  let s: string = "hello";
  let c = 'A';
  let f = 3.14;
  let n: string;
  let alias_value: NumOrText = "alias works";
  let alias_grid: Grid = {{1, 2}, {3, 4}};

  println(s);
  println(c);
  println(f);
  println(n);

  println(typeof(s));
  println(typeof(c));
  println(typeof(f));
  println(typeof(n));
  println(typeof(alias_value));
  println(typeof(alias_grid));

  println(int(true));
  println(bool(0));
  println(char(66));
  return;
}

fn demo_operators() {
  header("operators");

  let greeting = "Hello, " + "Twice!";
  println(greeting);
  println("x:" + 7);
  println("x:" + 3.5);
  println("x:" + 'A');
  println("line1\nline2\tend");

  let who = "Twice";
  println(`Hello ${who}\n`);

  println("Twice"[2]);
  let word = "array";
  println(word[0]);

  let n1 = 1 + 2.5;
  let n2 = 6 - 2.5;
  let n3 = 3 * 2.0;
  let n4 = 7 / 2.0;
  println(n1);
  println(n2);
  println(n3);
  println(n4);

  let mod_i = 7 % 4;
  let mod_f = 7.5 % 2.0;
  let mod_assign = 9;
  mod_assign %= 4;
  println(mod_i);
  println(mod_f);
  println(mod_assign);

  let acc = 10;
  acc += 2;
  acc -= 1;
  acc *= 3;
  acc /= 11;
  println(acc);

  let i = 3;
  i++;
  println(i);
  i--;
  println(i);

  let char_sum = 'A' + '1';
  let char_next = 'A' + 1;
  println(char_sum);
  println(char_next);

  println(true && false);
  println(true || false);
  println(true ^^ false);
  println(5 & 3);
  println(5 | 2);
  println(5 ^ 1);
  println(5 << 1);
  println(5 >> 1);
  return;
}

fn demo_control_flow_and_scopes() {
  header("control flow and scopes");

  let score = 10;
  if (score > 10) {
    println("big");
  } elif (score == 10) {
    println("equal");
  } else {
    println("small");
  };

  let scoped = 1;
  if (true) {
    let scoped = 2;
    println(scoped);
  };
  println(scoped);

  if (true) {
    scoped = 9;
  };
  println(scoped);

  {
    let temp = 77;
    println(temp);

    fn tempFn(x: int) int {
      return x + 1;
    }
    println(tempFn(10));
  }
  return;
}

fn demo_loops() {
  header("loops");

  let while_i = 0;
  while (while_i < 3) {
    while_i++;
  };
  println(while_i);

  let for_sum = 0;
  for (let j = 0; j < 4; j++) {
    for_sum = for_sum + j;
  };
  println(for_sum);

  for (let scoped_i = 0; scoped_i < 2; scoped_i++) {
    let loop_local = scoped_i;
    println(loop_local);
  };

  let control_sum = 0;
  for (let k = 0; k < 6; k++) {
    if (k == 2) {
      continue;
    };
    if (k == 5) {
      break;
    };
    control_sum = control_sum + k;
  };
  println(control_sum);

  let loop_count = 0;
  loop {
    loop_count++;
    if (loop_count == 2) {
      break;
    };
  };
  println(loop_count + " loop count");

  let loop_arr_sum = 0;
  let loop_arr_i = 0;
  while (loop_arr_i < 3) {
    let local_arr = {loop_arr_i, loop_arr_i + 1, loop_arr_i + 2};
    loop_arr_sum += local_arr[0];
    loop_arr_i++;
  };
  println(loop_arr_sum);
  return;
}

fn add(a: int, b: int = 2) int {
  return a + b;
}

fn sum7(a: int, b: int, c: int, d: int, e: int, f: int, g: int) int {
  return a + b + c + d + e + f + g;
}

fn demo_functions() {
  header("functions");

  println(add(5));
  println(add(3));
  println(add(a = 3, b = 4));
  println(add(3, b = 10));

  fn noop() {
    return;
  }
  println(noop());

  let y = 3;
  let getY = fn() int { return y; };
  let a1 = 1;
  let a2 = 2;
  let a3 = 3;
  let a4 = 4;
  let a5 = 5;
  let addCaps = fn(x: int, y: int) int { return a1 + a2 + a3 + a4 + a5 + x + y; };

  println((fn(a: int) int { return a + 1; })(2));
  println(getY());
  println(sum7(1, 2, 3, 4, 5, 6, 7));
  println(addCaps(6, 7));
  return;
}

fn demo_arrays_unions_tuples() {
  header("arrays unions tuples");

  let arr = {1, 2, 3};
  println(arr.length);
  println(arr.length());
  println(arr[1]);
  arr[1] = 99;
  println(arr[1]);

  let typed: int[3] = {4, 5, 6};
  println(typeof(typed));
  println(typed.length);
  println(typed.length());

  let fixed: int[3] = {7, 8, 9};
  println(typeof(fixed));

  let grid: int[2][2] = {{1, 2}, {2, 3}};
  println(typeof(grid));
  println(grid.length);
  println(grid.length());

  let value: int||string = 1;
  println(typeof(value));
  value = "twice";
  println(typeof(value));
  value = 3;
  if (value == 3) {
    println("union if works");
  };

  let gate: string||int = "x";
  gate = 5;
  if (gate == 5) {
    println("union reassign if works");
  };
  if (typeofValue(gate) == int) {
    println("typeofValue works");
  };

  let arr_or_text: int[3]||string = {1, 2, 3};
  println(typeof(arr_or_text));
  arr_or_text = "array or text";
  println(typeof(arr_or_text));

  let tri: int||string||bool = 1;
  tri = "ok";
  tri = true;
  println(typeof(tri));

  fn maybe_name(flag: bool) string||null {
    if (flag) {
      return "twice";
    };
    return;
  }
  maybe_name(false);
  maybe_name(true);

  let tup: (int, string, bool) = (7, "seven", true);
  println(typeof(tup));
  println(tup.0);
  println(tup.1);
  println(tup.2);

  type Pair = (int, string);
  type MaybePair = Pair||string;
  let maybe_pair: MaybePair = (1, "one");
  println(typeof(maybe_pair));
  println(maybe_pair.0);
  maybe_pair = "no pair";
  println(typeof(maybe_pair));

  let mixed = {1, "two", 3};
  println(typeof(mixed));
  println(mixed.length());

  let empty_arr: int[3] = {};
  println(empty_arr.length());

  let empty_pair: (int, string) = ();
  println(empty_pair.0 ?? 7);
  return;
}

fn demo_null_safe_and_coalesce() {
  header("null-safe and coalesce");

  let maybe_arr: int[3];
  println(maybe_arr?.length);
  println(maybe_arr?.length());
  println(maybe_arr?.length ?? 0);
  println(maybe_arr?.length() ?? 0);

  let arr = {1, 2, 3};
  println(arr?.length);
  println(arr?.length());
  println(arr?.length ?? 0);
  println(arr?.length() ?? 0);
  println(arr?.missing);
  println(arr?.missing());
  println(arr?.missing ?? "no member");
  println(arr?.missing() ?? "no method");

  println(hasField(arr, "length"));
  let field_name: string = "length";
  println(hasField(arr, field_name));
  field_name = "missing";
  println(hasField(arr, field_name));
  println(hasField("abc", "length"));
  println(hasField(1, "length"));

  let a: int;
  println(a ?? 42);
  println(7 ?? 42);
  return;
}

fn main() {
  demo_types_and_casts();
  demo_operators();
  demo_control_flow_and_scopes();
  demo_loops();
  demo_functions();
  demo_arrays_unions_tuples();
  demo_null_safe_and_coalesce();
  return;
}
